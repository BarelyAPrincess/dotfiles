#!/bin/bash

# Get the procs sorted by the number of inotify watches
# @author Carl-Erik Kopseng
# @latest https://github.com/fatso83/dotfiles/blob/master/utils/scripts/inotify-consumers
# Discussion leading up to answer: https://unix.stackexchange.com/questions/15509/whos-consuming-my-inotify-resources
# Speed enhancements by Simon Matter <simon.matter@invoca.ch>

usage(){
    cat << EOF
Usage: $0 [--help|--limits]

    -l, --limits    Will print the current related limits and how to change them
    -h, --help      Show this help
EOF
}

limits(){
    printf "\nCurrent limits\n-------------\n"
    sysctl fs.inotify.max_user_instances fs.inotify.max_user_watches

    cat <<- EOF


Changing settings permanently
-----------------------------
echo fs.inotify.max_user_watches=524288 | sudo tee -a /etc/sysctl.conf
sudo sysctl -p # re-read config

EOF
}

if [ "$1" = "--limits" -o "$1" = "-l" ]; then
    limits
    exit 0
fi

if [ "$1" = "--help" -o "$1" = "-h" ]; then
    usage 
    exit 0
fi

if [ -n "$1" ]; then
    printf "\nUnknown parameter '$1'\n" >&2
    usage
    exit 1
fi

generateData(){
    local -i PROC
    local -i PID
    local -i CNT
    local -i INSTANCES
    local -i TOT
    local -i TOTINSTANCES
    # read process list into cache
    local PSLIST="$(ps ax -o pid,user,command --columns $(( COLS - WLEN )))"
    IFS=","
    find /proc/*/fd -lname anon_inode:inotify 2> /dev/null |
        cut -d "/" -f 3 |                # get list of processes
        uniq |
        {
            while read -rs PROC; do      # count watches of processes found
                echo "${PROC},$(grep -c "^inotify" < <(cat /proc/${PROC}/fdinfo/* 2> /dev/null)),$(grep -l "^inotify" /proc/${PROC}/fdinfo/* 2>/dev/null | wc -l)"
            done
        } |
        grep -v ",0," |                  # remove entires without watches
        sort -n -t "," -k 2,3 -r |         # sort to begin with highest numbers
        {                                # group commands so that $TOT is visible in the printf
            while read -rs PID CNT INSTANCES; do   # show watches and corresponding process info
                printf "%$(( WLEN - 2 ))d  %$(( WLEN - 2 ))d     %s\n" "$CNT" "$INSTANCES" "$(grep -e "^\ *${PID}\ " <<< "$PSLIST")"
                TOT=$(( TOT + CNT ))
		TOTINSTANCES=$(( TOTINSTANCES + INSTANCES))
            done
	    # These stats should be per-user as well, since inotify limits are per-user..
            printf "\n%$(( WLEN - 2 ))d  %s\n" "$TOT" "WATCHES TOTAL COUNT"
            printf "\n%$(( WLEN - 2 ))d  %s\n" "$TOTINSTANCES" "TOTAL INSTANCES COUNT"
        }
    echo ""
    (echo "INSTANCES    USER"
     readlink -f /proc/*/fd/* |grep '^/proc/.*inotify' |cut -d/ -f3 | xargs -I '{}' -- ps --no-headers -o '%U' -p '{}'| sort | uniq -c|sort -nr) \
    | column -t |sed -e 's/^/     /'

}


# get terminal width
declare -i COLS=$(tput cols 2>/dev/null || echo 80)
declare -i WLEN=10

printf "\n%${WLEN}s\n" "INOTIFY"
printf "%${WLEN}s\n" "WATCHES"
printf "%${WLEN}s  %${WLEN}s  %s\n" " COUNT " "INSTANCES"    "PID USER     COMMAND"
printf -- "----------------------------------------------------\n"
generateData

# not fully implemented with command line switch, so just a executable note:
# print the # of instances (not watches)
if [ -n "$PRINT_INSTANCES" ]; then
    FIL=$(mktemp)
    readlink -f /proc/*/fd/* |grep '^/proc/.*inotify' |cut -d/ -f3 | xargs -I '{}' -- ps --no-headers -o '%p %U %a' -p '{}' |uniq -c |sort -n > $FIL
    cat $FIL 
    echo "TOTAL = $(total=0 cat $FIL | awk '{print $1}' | { while read num; do let total+=$num; done; echo $total; })"
    rm $FIL
fi

